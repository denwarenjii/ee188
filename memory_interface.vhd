----------------------------------------------------------------------------
--
--  Memory Interface
--
--  These entities act as interfaces between the SH-2 CPU and the memory unit
--  being used to simulate SRAM (memory.vhd). These entities take control
--  signals generated by the control unit and use them to read/write to the
--  memory, performing byte shifting and conversions between little-endian and
--  big-endian as necessary. Note that the SH-2 CPU treats memory as big-endian,
--  though our internal implementation uses little-endian representation.
--  However, this interface should handle all conversions, and so the rest of
--  the CPU should not core about endianness at all. To avoid complications
--  with the data bus being inout, this memory interface is split into
--  MemoryInterfaceTx, which outputs signals to initiate a read/write, and
--  MemoryInterfaceRx, which reads back data returned from the data bus. If
--  using this interface, the data bus should not be used elsewhere, as these
--  entities provide the complete interface for reading/writing memory.
--
--  Revision History:
--     03 May 25  Zack Huang        Implement memory interface for byte,
--                                  word, and longword read/writes.
--     16 May 25  Zack Huang        Add documentation
--
----------------------------------------------------------------------------

library ieee;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

package MemoryInterfaceConstants is

    -- MemEnable constants
    constant MemEnable_OFF  : std_logic := '0';     -- disble memory reading/writing
    constant MemEnable_ON   : std_logic := '1';     -- enable memory reading/writing

    -- MemMode constants (BIT-DECODED, DO NOT CHANGE VALUES)
    constant ByteMode       : std_logic_vector(1 downto 0) := "00"; -- read/write a single byte
    constant WordMode       : std_logic_vector(1 downto 0) := "01"; -- read/write two bytes as a word
    constant LongwordMode   : std_logic_vector(1 downto 0) := "10"; -- read/write four bytes as a longword

    -- ReadWrite constants
    constant Mem_READ       : std_logic := '0';     -- read from memory
    constant Mem_WRITE      : std_logic := '1';     -- write to memory

end package MemoryInterfaceConstants;


library ieee;
library std;

use std.textio.all;

use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.MemoryInterfaceConstants.all;
use work.sh2utils.all;
use work.Logging.all;

-- MemoryInterfaceTx
--
-- This entity implements the "output" portion of the memory interface, in that
-- it takes in control signals from the CPU and outputs the necessary
-- read-enables/write-enables and values on the data bus in order to perform
-- a read/write. Control signals allow for this unit to be enabled/disabled,
-- and to use different memory access modes (byte, word, longword). Though this
-- entity does not output to the CPU address bus, it must know the address in
-- order to mask the right enable bits for reading/writing. Note that when
-- performing a write, the MemDataIn input is truncated to the low 8 bits in
-- byte mode and the low 16 bits for word mode.
--
entity MemoryInterfaceTx is
    port (
        clock     :  in     std_logic;                          -- system clock
        MemEnable :  in     std_logic;                          -- if memory interface should be active or not
        ReadWrite :  in     std_logic;                          -- memory read (0) or write (1)
        MemMode   :  in     std_logic_vector(1 downto 0);       -- memory access mode (byte, word, or longword)
        Address   :  in     unsigned(31 downto 0);              -- memory address bus (MUST BE ALIGNED!)
        MemDataOut   :  in     std_logic_vector(31 downto 0);      -- the input to write to memory
        RE        :  out    std_logic_vector(3 downto 0);       -- read enable mask (active low)
        WE        :  out    std_logic_vector(3 downto 0);       -- write enable mask (active low)
        DB        :  out    std_logic_vector(31 downto 0)       -- memory data bus
    );
end entity;


architecture structural of MemoryInterfaceTx is
begin

    output_proc: process(MemEnable, ReadWrite, MemMode, Address, MemDataOut, clock)
      variable l : line;
    begin
        -- When clock goes low, if this interface is enabled and should perform
        -- either a read or a write, then output the read-enable and
        -- write-enable signals in order depending on the memory mode to
        -- read/write a byte, word, or longword.
        if MemEnable = MemEnable_ON and clock = '0' and not is_x(address) then
            if ReadWrite = Mem_READ then    -- If performing a read
                WE(3 downto 0) <= (others => '1');  -- Disable writing
                DB <= (others => 'Z');              -- set data bus to high impedance so it can be read from

                -- Enable specific bytes based on type of read
                case MemMode is
                    when ByteMode =>
                        -- Enable only the specific byte being read
                        RE(0) <= '0' when address mod 4 = 0 else '1';
                        RE(1) <= '0' when address mod 4 = 1 else '1';
                        RE(2) <= '0' when address mod 4 = 2 else '1';
                        RE(3) <= '0' when address mod 4 = 3 else '1';

                        LogWithTime(l, "memory_interface.vhd: Reading byte at address 0x" & to_hstring(address), LogFile);

                    when WordMode =>
                        assert (address mod 2 = 0)
                        report "Memory interface Tx: Cannot read word from non-aligned address: " & to_hstring(address)
                        severity error;

                        -- Enable only the specific pair of bytes being read (address must be word-aligned)
                        RE(0) <= '0' when address mod 4 = 0 else '1';
                        RE(1) <= '0' when address mod 4 = 0 else '1';
                        RE(2) <= '0' when address mod 4 = 2 else '1';
                        RE(3) <= '0' when address mod 4 = 2 else '1';

                        LogWithTime(l, "memory_interface.vhd: Reading word at address 0x" & to_hstring(address), LogFile);

                    when LongwordMode =>
                        assert (address mod 4 = 0)
                        report "Memory interface Tx: Cannot read longword from non-aligned address: " & to_hstring(address)
                        severity error;

                        -- Enable all bytes to read a longword. Address must be longword-aligned.
                        RE(3 downto 0) <= (others => '0');

                        LogWithTime(l, "memory_interface.vhd: Reading longword at address 0x" & to_hstring(address), LogFile);

                    when others =>
                        assert (false)
                        report "Memory interface Tx: unrecognized read mode" & to_hstring(address)
                        severity error;

                        -- When unrecognized mode, don't read/write anything
                        RE <= (others => '1');

                end case;

            elsif ReadWrite = Mem_WRITE then        -- If performing a write:
                RE(3 downto 0) <= (others => '1');  -- Disable reading
                DB <= (others => 'Z');              -- Set data bus bytes to high impedance by default

                -- Enable specific bytes based on memory mode
                case MemMode is
                    when ByteMode =>
                        -- Enable only the specific byte being written
                        WE(0) <= '0' when address mod 4 = 0 else '1';
                        WE(1) <= '0' when address mod 4 = 1 else '1';
                        WE(2) <= '0' when address mod 4 = 2 else '1';
                        WE(3) <= '0' when address mod 4 = 3 else '1';

                        -- Set the correct data bus byte to the byte being written
                        if address mod 4 = 0 then 
                            DB(7 downto 0)   <= MemDataOut(7 downto 0);
                        elsif address mod 4 = 1 then 
                            DB(15 downto 8)  <= MemDataOut(7 downto 0);
                        elsif address mod 4 = 2 then 
                            DB(23 downto 16) <= MemDataOut(7 downto 0);
                        elsif address mod 4 = 3 then 
                            DB(31 downto 24) <= MemDataOut(7 downto 0);
                        end if;

                        LogWithTime(l, "memory_interface.vhd: Writing byte (0x" & to_hstring(MemDataOut(7 downto 0)) &
                                       ") at address 0x" & to_hstring(address), LogFile);

                    when WordMode =>
                        assert (address mod 2 = 0)
                        report "Memory interface Tx: Cannot write word to non-aligned address: " & to_hstring(address)
                        severity error;

                        -- Enable only the specific pair of bytes being read (address must be word-aligned)
                        WE(0) <= '0' when address mod 4 = 0 else '1';
                        WE(1) <= '0' when address mod 4 = 0 else '1';
                        WE(2) <= '0' when address mod 4 = 2 else '1';
                        WE(3) <= '0' when address mod 4 = 2 else '1';

                        if address mod 4 = 0 then
                            -- Convert input data from little-endian to big-endian by reversing the bytes,
                            -- the output to the low word of the data bus
                            DB(15 downto 0) <= MemDataOut(7 downto 0) & MemDataOut(15 downto 8);

                            LogWithTime(l, "memory_interface.vhd: Writing word (0x" & 
                                            to_hstring(MemDataOut(7 downto 0) & MemDataOut(15 downto 8)), LogFile);
                        elsif address mod 2 = 0 then
                            -- Convert input data from little-endian to big-endian by reversing the bytes,
                            -- the output to the high word of the data bus
                            DB(31 downto 16) <= MemDataOut(7 downto 0) & MemDataOut(15 downto 8);

                            LogWithTime(l, "memory_interface.vhd: Writing word (0x" & 
                                            to_hstring(MemDataOut(7 downto 0) & MemDataOut(15 downto 8)), LogFile);
                        end if;

                        LogWithTime(") at address 0x" & to_hstring(address), LogFile);

                    when LongwordMode =>
                        assert (address mod 4 = 0)
                        report "Memory interface Tx: Cannot write longword to non-aligned address: " & to_hstring(address)
                        severity error;

                        -- Enable all bytes to read a longword. Address must be longword-aligned.
                        WE(3 downto 0) <= (others => '0');

                        -- Reverse bytes to convert little-endian to big-endian
                        DB(7 downto 0) <= MemDataOut(31 downto 24);
                        DB(15 downto 8) <= MemDataOut(23 downto 16);
                        DB(23 downto 16) <= MemDataOut(15 downto 8);
                        DB(31 downto 24) <= MemDataOut(7 downto 0);

                        LogWithTime(l, "memory_interface.vhd: Writing longword (0x" & to_hstring(MemDataOut) &
                                       ") at address 0x" & to_hstring(address), LogFile);

                    when others =>
                        assert (false)
                        report "Memory interface Tx: Invalid memory mode for write"
                        severity error;

                        -- When unrecognized mode, don't read/write anything
                        WE(3 downto 0) <= (others => '1');

                end case;
            end if;
        else
            -- should not enable memory interface
            RE <= (others => '1');
            WE <= (others => '1');
        end if;

    end process output_proc;
end architecture;


library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

use work.MemoryInterfaceConstants.all;
use work.sh2utils.all;

-- MemoryInterfaceRx
--
-- This entity implements the "input" portion of the memory interface, in that
-- it reads bits returned from the data bus after a read is performed and
-- converts it from big-endian back into little-endian, which is used
-- internally. The memory mode and address of the read that was performed must
-- be provided so this entity knows how to shift the bytes into the correct
-- positions. All inputs are sign-extended to 32 bits in accordance with the
-- SH-2 spec.
--
entity MemoryInterfaceRx is
    port (
        MemEnable :  in     std_logic;                        -- if memory interface should be active or not
        MemMode   :  in     std_logic_vector(1 downto 0);     -- memory access mode (byte, word, or longword)
        Address   :  in     unsigned(31 downto 0);            -- memory address bus
        DB        :  in     std_logic_vector(31 downto 0);    -- memory data bus
        MemDataIn :  out    std_logic_vector(31 downto 0)     -- data read from memory
    );
end entity;

architecture structural of MemoryInterfaceRx is
begin
    output_proc: process(MemEnable, MemMode, Address, DB)
    begin
        if MemEnable = MemEnable_ON then
            -- Shift and sign-extend based on the mode
            case MemMode is
                when ByteMode =>
                    -- Mask out the correct byte from the data bus and sign-extend
                    if (Address mod 4 = 0) then
                        MemDataIn(7 downto 0) <= DB(7 downto 0);
                        MemDataIn(31 downto 8) <= (others => DB(7));
                    elsif (Address mod 4 = 1) then
                        MemDataIn(7 downto 0) <= DB(15 downto 8);
                        MemDataIn(31 downto 8) <= (others => DB(15));
                    elsif (Address mod 4 = 2) then
                        MemDataIn(7 downto 0) <= DB(23 downto 16);
                        MemDataIn(31 downto 8) <= (others => DB(23));
                    elsif (Address mod 4 = 3) then
                        MemDataIn(7 downto 0) <= DB(31 downto 24);
                        MemDataIn(31 downto 8) <= (others => DB(31));
                    end if;
                        
                when WordMode =>
                    -- Mask out the correct pair of byte from the data bus, reverse
                    -- their order to convert them from big-endian to little-endian,
                    -- and then sign-extend them
                    if (Address mod 4 = 0) then
                        MemDataIn(7 downto 0)  <= DB(15 downto 8);
                        MemDataIn(15 downto 8) <= DB(7 downto 0);
                        MemDataIn(31 downto 16) <= (others => DB(15));
                    elsif (Address mod 4 = 2) then
                        MemDataIn(7 downto 0) <= DB(31 downto 24);
                        MemDataIn(15 downto 8) <= DB(23 downto 16);
                        MemDataIn(31 downto 16) <= (others => DB(31));
                    end if;

                when LongwordMode =>
                    -- Reverse the read bytes from the data bus to convert them
                    -- from big-endian to little-endian. No sign-extension is
                    -- necessary.
                    MemDataIn(7 downto 0) <= DB(31 downto 24);
                    MemDataIn(15 downto 8) <= DB(23 downto 16);
                    MemDataIn(23 downto 16) <= DB(15 downto 8);
                    MemDataIn(31 downto 24) <= DB(7 downto 0);

                when others =>
                    assert (false)
                    report "Memory interface Rx: Invalid memory mode"
                    severity error;

                    -- When invalid memory mode, don't read anything
                    MemDataIn <= (others => 'X');
            end case;
        else
            -- Interface not enabled, don't read anything
            MemDataIn <= (others => 'X');
        end if;

    end process output_proc;

end architecture;
